(in-package :subalgebras)

(define-simple-condition subalgebra-error)

;;; calculate generating elements

(defun calculate-generating-elements (algebra)
  (declare (type algebra algebra))
  "Returns list of generating elements of ALGEBRA of minimal length."
  (labels ((check-incremental (n)
             (let ((elements (n-elements-generate-algebra algebra n)))
               (cond
                 (elements elements)
                 (t (check-incremental (1+ n)))))))
    (check-incremental 0)))

(defun n-elements-generate-algebra (algebra number-of-elements)
  (declare (type algebra algebra)
           (type integer number-of-elements))
  "Return list of NUMBER-OF-ELEMENTS elements of ALGEBRA if NUMBER-OF-ELEMENTS
  elements in ALGEBRA exists which generate the whole ALGEBRA."
  (labels ((check-first-subset-generates-algebra (subset)
             (cond
               ((emptyp-s subset) nil)
               ((elements-generate-algebra-p (first-s subset) algebra)
                (first-s subset))
               (t (check-first-subset-generates-algebra (rest-s subset))))))
    (check-first-subset-generates-algebra
      (n-elemental-subsets (base-set-of algebra)
                            number-of-elements))))

(defun elements-generate-algebra-p (elements algebra)
  "Return non-NIL if ELEMENTS generate ALGEBRA."
  (declare (type standard-set elements)
           (type algebra algebra))
  (let ((reachable-elements (all-reachable-elements elements algebra)))
    (cond
      ((set-equal reachable-elements (base-set-of algebra)) t)
      (t nil))))

(defun all-reachable-elements (elements algebra)
  "Returns all reachable elements from ELEMENTS in ALGEBRA."
  (declare (type standard-set elements)
           (type algebra algebra))
  (let ((new-element (next-reachable-element algebra elements)))
    (cond
      ((not new-element) elements)
      (t (all-reachable-elements (add-element-s new-element elements) algebra)))))

(defun next-reachable-element (algebra reachable-elements)
  "Returns new element in ALGEBRAS which is reachable by elements
   from REACHABLE-ELEMENTS"
  (declare (type algebra algebra)
           (type standard-set reachable-elements))
  (let ((value-tables (interpretations-on algebra)))
    (loop-over-set table value-tables
      (iterate-over-function-graph
	  (implementing-function-of table) element
	(when (and (subsetp-s (make-set (all-operands element)) reachable-elements)
		   (not (set-member-s (value-of-element element)
				      reachable-elements)))
	  (return-from next-reachable-element
	    (values (value-of-element element)
		    (all-operands element)
		    (function-symbol-of table))))))))

;;; here is still a lot todo

(defun subalgebra-generated-by-elements (algebra elements)
  "Returns subalgebra in ALGEBRA generated by ELEMENTS being a set of elements
   in ALGEBRA."
  (declare (type algebra algebra)
           (type standard-set elements))
  (cond
    ((not (subsetp-s elements (base-set-of algebra)))
     (error 'subalgebra-error :text
            (format nil "Cannot generate algebra ~A from elements ~A~
                        ~%not being in the algebra." algebra elements)))
    (t (let ((new-base-set (all-reachable-elements elements algebra)))
         (cond
           ((emptyp-s new-base-set)
            (error 'subalgebra-error
                   :text "Cannot generate subalgebra from empty set."))
           (t (make-algebra new-base-set
                            (signature-of algebra)
                            (restrict-interpretations-to-set
			     (interpretations-on algebra)
			     new-base-set
			     (signature-of algebra)))))))))

(defun restrict-interpretations-to-set (interpretations set signature)
  (declare (type standard-set interpretations set)
           (type signature signature))
  (mapset #'(lambda (interpre)
              (restrict-table-to-set interpre set signature))
          interpretations))

(defun restrict-table-to-set (table set signature)
  (declare (type table table)
           (type standard-set set)
           (type signature signature))
  (let ((func-symbol (function-symbol-of table)))
    (list func-symbol
          (restrict-function-on-target
           (restrict-function-on-source
            (implementing-function-of table)
            (tuples set (arity-of-function-symbol signature func-symbol)))
           set))))

;;;

;; (defun extend-graph-to-homomorphism-into-termalgebra (algebra graph)
;;   "Returns function being a homomorphism from ALGEBRA into the term-algebra
;; generated by the source of GRAPH being a subset of (BASE-SET-OF ALGEBRA)"
;;   (let ((source (mapcar #'first graph)))
;;     (cond
;;       ((not (subsetp (base-set-of algebra) source :test (equal-pred-of-algebra algebra)))
;;        (error 'subalgebra-error :text (format nil "Base set of ~A is not superset of source of ~A"
;;                                               algebra graph)))
;;       (t (let ((func (extend-from-elements-into-termalgebra algebra source graph)))
;;            (cond
;;              ((homomorphism-into-termalgebra-p func algebra
;;                                                (make-term-algebra source (signature-of algebra)))
;;               func)
;;              (t nil)))))))

;; (defun homomorphism-into-termalgebra-p (function algebra term-algebra)
;;   (and (set-equal (source function) (base-set-of function) :test (equal-pred-of-algebra algebra))
;;        (forall (element (base-set-of algebra))
;;          (let ((value (apply-function-to-element function element)))
;;            (termp term-algebra value)))

(defun extend-from-elements-into-termalgebra (algebra source graph)
  (declare (type algebra algebra)
           (type standard-set source graph))
  (multiple-value-bind (next-element operands function-symbol)
      (next-reachable-element algebra source)
    (cond
      ((null next-element)
       (make-function (mapset #'first graph)
                      (mapset #'second graph)
                      graph))
      (t (let ((converted-operands
                 (mapcar
                   #'(lambda (x)
                       (second (assoc-s x graph)))
                   operands)))
           (extend-from-elements-into-termalgebra
             algebra
             (add-element-s next-element source)
             (add-element-s (list next-element
				  (cons function-symbol converted-operands))
			    graph)))))))

(defun homomorphism-from-assignment (algebra elements graph)
  "Returns homomorphism extending GRAPH on ELEMENTS."
  (declare (type algebra algebra)
           (type standard-set elements graph))
  (cond
    ((not (elements-generate-algebra-p elements algebra))
     (error 'subalgebra-error :text
            (format nil "~A do not generate ~A" elements algebra)))
    ((not (subsetp-s elements (mapset #'first graph)))
     (error 'subalgebra-error :text
            (format nil "~A is not an assignment of ~A" graph elements)))
    (t (extend-from-elements-into-termalgebra algebra elements graph))))

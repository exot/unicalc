#define EXTERN extern
#include "includes.h"

#ifdef RUN_PROGRESS
double tick_count(ALG *, int );
#endif /* RUN_PROGRESS */

int
spf( ALG *A, VECTORS *gen, ARGSLIST *argsl_given, 
                  int (*check)( NEW_TUPLE *, void *), void *checkargs)
/*  
  A is an algebra, gen lists tuples in a power of A.
  This routine computes the subalgebra generated by these,
  and returns it in gen. It reallocates gen->list.
  Returns ERROR on error, ABORT of (*check)() returns ABORT,
  NO_ERROR otherwise. May return INTERRUPT.

  The algorithm used here is the same as the algorithm used
  in the program in the paper "Free lattices in some small varieties"
  by Joel Berman and Barry Wolk.

  A hashing algorithm is used. To every tuple a hasing number
  is assigned by hash(), which is an int between 0 and HASH_SIZE.
  When a new tuple is generated, to decide if it is among the
  old ones, we first compute its hashing number. If it is new,
  the tuple is new. Otherwise, the tuple is compared to all
  old tuples with identical hashing numbers.

  The tuples with identical hashing numbers are stored in chains.
  The tuple at address (gen->list)[i] is referred to by i.
  The array first[HASH_SIZE] stores the first entries of these chains.
  first[h] is either -1, or contains i, if the i-th tuple is the
  first one with hashing number h. The array next[] contains
  the subsequent elements of these chains. Namely,
  next[i]= j, if the i-th and j-th tuple have the same hashing
  number, and i -< j. If j is the last element of the chain, then
  next[j]= -1.

  In order to avoid calculating the result of an operation twice,
  the tuples are considered to be in levels. The first level
  is the set of generators. The (k+1)-th level is obtained
  from the k-th one by performing all the operations.

  As execution time is critical in this routine, we
  had to use goto statements to avoid subroutine calls.
  Actually, these goto statements make break statements clearer.

  The function (*check)() is applied to every
  newly generated element. If the result is NO_ERROR, then
  the processing continues. If it is ABORT, then processing is
  aborted. If (*check)() is NULL, then no checking takes place.
  A function in the (*check)() argument must have three arguments:
  (*check)( VEC, void *), where the VEC argument is the newly
  generated vector, and the second pointer points to a
  structure containing the parameters of (*check)().
  (The length of the VEC argument should also be supplied this way.)

  Execution speed is crucial here. However, what takes long
  is checking if there are no new vectors, and if there is
  an at least binary operation, then that is at least the
  square of the number of vectors. Therefore we can afford
  to use spf() everywhere.

  The start time of the routine is recorded, and a progress
  report is generated at certain intervals.

  For every newly generated tuple, the corresponding
  arguments are put into `argsl'.
  This is not done if argsl==NULL.
*/
{
  int max_arity;
  int powers[ARITY_LIMIT+1];
  long power;
  int *first = NULL;
  int *next = NULL;
  int size_next;
  int i, j;
  int m;
  int found;
  int level_limit, args_limit;
  FUNCT *op;
  int opno;
  int ar;
  int args[ARITY_LIMIT];
  int offset;
  VEC* gennew;
  VEC generated = NULL;
  int err;
  NEW_TUPLE nt;
  ARGSLIST* argsl;
  ARGSLIST argsl_here; /* If argsl_given is NULL, then we use this */
  ARGUMENTS arg_st;
  char *out; /* print arguments on ABORT */

#ifdef RUN_PROGRESS
  double all;           /* all ticks needed (as it seems at the moment) */
  double tick;          /* # of ticks elapsed so far */
  double elapsed_ratio; /* basically tick/all */
  int tick_mod;         /* # of ticks elapsed since the last report */
  int old_gennum;       /* # of generated vectors at the last report */
#ifdef TIME_DIAG
  time_t start_time; /* time when routine started */
  time_t last_time; /* last_time when a diagnostic message was printed */
#endif /* TIME_DIAG */
#endif /* RUN_PROGRESS */

/* end of variables, start of function  */

/* initialize argsl */
  argsl=argsl_given;
  if(argsl_given==NULL) argsl= &argsl_here;
  argsl->nargs_st=0;
  argsl->list=NULL;
/* initialize nt */
  nt.alg=A;
  nt.gen=gen;
  nt.argsl=argsl;

  print_spopen("Berman's routine invoked.");
  print_spinput("Power: %d", gen->lvecs);

/* preliminaries */

/* get maximum arity in A */
  max_arity= get_max_arity(A);
  if( max_arity == ERROR )
  {
    goto WLerror;
  }

/* compute and store powers of A->size */

  m= ((gen->lvecs>max_arity) ? gen->lvecs : max_arity);
                        /* m= max(gen->lvecs,max_arity) */


  power = (long)1;
  powers[0]= 1;
  size_next= VEC_NUM_LIMIT;
  for (i= 1;i<= m;i++)
  {
    power *= (long)(A->size);
    if (power <= (long)0 )
    {
      print_derr("Overflow in multiplication. EC 0002");
      goto WLerror;
    }
    if (power > (long)POWER_LIMIT)
    {
      if(i<= max_arity)
      {
        print_derr("Arity too big: cannot use operation. EC 0003");
        goto WLerror;
      }
      else
      {
        size_next= VEC_NUM_LIMIT;
        break;
      }
    }
    if(i < max_arity)
    {
      powers[i]= (int)power;
    }
    if(i== gen->lvecs && 1+(int)power <= VEC_NUM_LIMIT)
    {
      size_next= 1+(int)power;
    }
  }

/* Check number of generators */

  if(gen->nvecs>= size_next)
  {
    print_derr("No room to store generators. EC 0004");
    goto WLerror;
  }

/*This is a lie. It could happen that first[] and next[]
  TOGETHER could store them. However, to make a more elaborate
  check of whether next[???] is always legitimate
  would slow the program down. Therefore we shall not allow
  here, nor later, gen->nvecs to grow beyond size_next.
*/

/* allocate and initialize first[] and next[] */

  if ((first= (int *)(calloc(HASH_SIZE,sizeof(int))))== NULL)
  {
    print_derr("Not enough memory. EC 0005");
    goto WLerror;
  }

  if ((next= (int *)(calloc(size_next,sizeof(int))))== NULL)
  {
    print_derr("Not enough memory. EC 0006");
    goto WLerror;
  }

  if ((generated= (VEC)(calloc(gen->lvecs,sizeof(int))))== NULL)
  {
    print_derr("Not enough memory. EC 0007");
    goto WLerror;
  }

  for (i= 0;i<size_next;i++)
  {
    next[i]= -1;
  }
  for (i= 0;i<HASH_SIZE;i++)
  {
    first[i]= -1;
  }

/* put the generators into first[] and next[] */

  print_npinput("The %d generators:", gen->nvecs);
  for (i= 0;i<gen->nvecs;i++)
  {
    found = hash((gen->list)[i],gen->lvecs);
    if (first[found] == -1)
    {
      first[found]= i;      /* chain in */
      goto WLnextgen;      /* next generator; could be `continue' */
    }
    found= first[found];
    for(;;)              /* deal with present tuple */
    {
      for (j= 0;j<gen->lvecs;j++)  /* is this a different tuple? */
      {
        if (((gen->list)[i])[j]!= ((gen->list)[found])[j])
        {
          goto WLdiffgen;    /* Yes, it is */
        }
      }
      print_derr("Error: same generator used twice. EC 0008");
      goto WLerror;
WLdiffgen:
      if(next[found]== -1)
      {
        next[found]= i;
        goto WLnextgen;      /* next generator; could be `break' */
      }
      found= next[found];
    }
WLnextgen:
    /* put the arguments into argsl */
    arg_st.result=i;
    arg_st.args=NULL;
    err=concat_arg_st( &arg_st, argsl);
    if(err!=NO_ERROR) goto WLerror;
/* check generators with (*check)() */
    print_npinput("G%5d: ",i);
    print_r_vector(gen->lvecs, (gen->list)[i]);
    if(check!=NULL) {
      nt.offset=i;
      err=(*check)( &nt, checkargs);
      if(err==ABORT ) goto WLabort;
      if(err!=NO_ERROR ) goto WLerror;
    }
  }
  print_spres("Newly generated elements: ");


/*  Generators inserted, now compute new `levels'.
  For a k-ary operation f, we compute 
  f(args[0],...,args[k-1]) for all possible values
  of 0<= args[i]<gen->nvecs.
  The variable level_limit is such, that the operations
  have already been performed for all values
  0<= args[i]<level_limit.
*/

#ifdef RUN_PROGRESS
  tick=(double)0;
  tick_mod=0;
  old_gennum=gen->nvecs;
  all=tick_count(A, gen->nvecs);
#ifdef TIME_DIAG
/* record the time */
  start_time=time( NULL );
  last_time=start_time;
#endif /* TIME_DIAG */
#endif /* RUN_PROGRESS */

  level_limit= 0;
  args_limit= gen->nvecs;
  for(;;)      /* this cycles through levels */
  {          /* level_limit, args_limit are fixed inside */
    op= A->func;
    opno=0;
    while(op != NULL)  /* perform all operations, op fixed inside */
    {
      ar= op->arity;

      if(gen->nvecs== 0 && ar>0)
      {
        goto WLnextop;    /* only nullary op's on empty set */
      }

/* The arity cycle is always performed at least once, with the
   exception when arity>0 and there are no generators. 
   For nullary operations this works right. 
   A different approach could be to perform the unary operations
   first, and then increase and test args[] at the beginning
   of the cycle. */

      args[0]= level_limit;  /* causes no trouble if ar== 0 */
      for (i= 1;i<ar;i++)
      {
        args[i]= 0;
      }
      for(;;)      /* perform operation `op', args[] fixed inside */
      {

	  if(StopIt == YES) goto WLinterrupt;

#ifdef RUN_PROGRESS
        tick += (double)1;
        tick_mod++;
        if(tick_mod >= WSPF_PROGR_TICKS )
        {
          tick_mod=0;
          if( (gen->nvecs) > old_gennum ) {
            all=tick_count(A, gen->nvecs);
            old_gennum=gen->nvecs;
          }
          if( all <= (double)0 ) elapsed_ratio=(double)0;
          else elapsed_ratio= tick/all;
          print_time_progr( 
#ifdef TIME_DIAG
                                start_time, &last_time, 
#endif /* TIME_DIAG */
                                elapsed_ratio, "Berman's routine.");
        }
#endif /* RUN_PROGRESS */
        for (i= 0;i<gen->lvecs;i++)
        {
          offset= 0;
          for (j= 0;j<ar;j++)
          {
            offset += (((gen->list)[args[j]])[i]) * powers[j];
          }
          generated[i] = op->values[offset];  /* fine for ar= 0 */
        }
        found = hash(generated,gen->lvecs);
        if (first[found] == -1)      /* this is a new tuple */
        {
          first[found]= gen->nvecs;
          goto WLchain_in;
        }
        found= first[found];
        for(;;)    /* decide if this tuple is new, chain it in */
        {        /* `found' fixed inside this cycle */
          for (j= 0;j<gen->lvecs;j++)/* is this a different tuple? */
          {
            if (generated[j]!= ((gen->list)[found])[j])
            {
              goto WLdifftup;
            }
          }
          goto WLnextargs;  /* not a new tuple */
WLdifftup:                
          if(next[found]== -1)    /* This is a new tuple */
          {
            next[found]= gen->nvecs;  /* chain in */
WLchain_in:              
            if(gen->nvecs>= size_next)
            {
              print_derr("No room for generated elements. EC 0011");
              goto WLerror;
            }
            gennew= (VEC *)(realloc(gen->list,
                          ((gen->nvecs)+1)*sizeof(VEC)));
            if (gennew== (VEC *)NULL)
            {
              print_derr("Not enough continuous memory. EC 0012");
              print_nerr("Number of tuples=%d", gen->nvecs);
              goto WLerror;
            }
            gen->list= gennew;
            (gen->list)[gen->nvecs]=
                        (VEC)(calloc(gen->lvecs,sizeof(int)));
            if ((gen->list)[gen->nvecs]== NULL)
            {
              print_derr("Not enough memory. EC 0013");
              print_nerr("Number of tuples=%d", gen->nvecs);
              goto WLerror;
            }
            for (j= 0;j<gen->lvecs;j++)  /* copy new tuple */
            {
              ((gen->list)[gen->nvecs])[j]= generated[j];
            }
            (gen->nvecs)++;
            print_spres("V%5d: ",(gen->nvecs)-1);
            print_r_vector(gen->lvecs, generated);
            print_npres("        = f%d", opno);
            print_r_vector(ar, (VEC)args);
/* (*check)() new tuple */
            /* put the arguments into argsl */
            arg_st.opno=opno;
            arg_st.arity=ar;
            arg_st.args=args;
            arg_st.result=(gen->nvecs)-1;
            err=concat_arg_st( &arg_st, argsl);
            if(err!=NO_ERROR) goto WLerror;
            if(check!=NULL) {
              nt.offset=(gen->nvecs)-1;
              err=(*check)( &nt, checkargs);
              if(err==ABORT ) goto WLabort;
              if(err!=NO_ERROR ) goto WLerror;
            }
            goto WLnextargs;    /* get new args */
          }
          found= next[found];
        }  /* the generated tuple has been dealt with */
WLnextargs:
        for(i= 0;i<ar;i++) /* args[0] runs fastest */
        {
          args[i]++;
          if (args[i]>= args_limit)
          {
            args[i]= 0;
            continue;  /* get next coordinate */
          }
          break;      /* args[i] has been increased */
        }
        if (i== ar)    /* no new args[], OK for ar== 0 */
        {
          goto WLnextop;    /* get next operation */
        }
        for(;i<ar;i++)
        {
          if (args[i]>= level_limit)
          {
            goto WLargsok;
          }
        }
        args[0]= level_limit;
WLargsok:;      /* new args has been computed */
      }    /* op has been completed */
WLnextop:
      op= op->next;
      opno++;
    }    /* get next operation */
    if(gen->nvecs== args_limit)
    {
      goto WLfinished;    /* No new tuple has occured */
    }
    level_limit= args_limit;
    args_limit= gen->nvecs;
  }      /* get next level */
WLfinished:
  if (first!= (int *)NULL) free((void *)first);
  if (next!= (int *)NULL) free((void *)next);
  if (generated!= (VEC)NULL) free((void *)generated);
  print_spclose("Berman's routine finished.");
  print_spres("The generated subpower contains %d vector(s).",
                                                          gen->nvecs);

  if(argsl_given==NULL) free_argslist(argsl);
  return(NO_ERROR);

WLerror:
  if (first!= (int *)NULL) free((void *)first);
  if (next!= (int *)NULL) free((void *)next);
  if (generated!= (VEC)NULL) free((void *)generated);
  if(argsl_given==NULL) free_argslist(argsl);
  return(ERROR);

WLinterrupt:
  if (first!= (int *)NULL) free((void *)first);
  if (next!= (int *)NULL) free((void *)next);
  if (generated!= (VEC)NULL) free((void *)generated);
  if(argsl_given==NULL) free_argslist(argsl);
  return(INTERRUPT);

WLabort:
  print_spclose("Berman's routine aborted.");
  err=build_expression(gen, argsl, (argsl->nargs_st)-1, &out);
  if(err==NO_ERROR) print_npres("%s", out);
  if(out!=NULL) free((void *)(out));

  if (first!= (int *)NULL) free((void *)first);
  if (next!= (int *)NULL) free((void *)next);
  if (generated!= (VEC)NULL) free((void *)generated);
  if(argsl_given==NULL) free_argslist(argsl);
  return(ABORT);
}

#ifdef RUN_PROGRESS
double
tick_count(ALG *A, int gennum)
/* Counts the number of ticks needed to check gennum generators. 
*/
{
  FUNCT *op;
  double all;

  if(gennum<=0) return(0);
  all=0;
  op= A->func;
  while(op != NULL)
  {
    all += pow((double)gennum, (double)(op->arity));
    op= op->next;
  }
  return(all);
}
#endif /* RUN_PROGRESS */


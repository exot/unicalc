(in-package :subalgebras)

(define-simple-condition subalgebra-error)

;;; calculate generating elements

(defun calculate-generating-elements (algebra)
  "Returns list of generating elements of ALGEBRA of minimal length."
  (labels ((check-incremental (n)
             (let ((elements (n-elements-generate-algebra algebra n)))
               (cond
                 (elements elements)
                 (t (check-incremental (1+ n)))))))
    (check-incremental 0)))

(defun n-elements-generate-algebra (algebra number-of-elements)
  "Return list of NUMBER-OF-ELEMENTS elements of ALGEBRA if NUMBER-OF-ELEMENTS elements
in ALGEBRA exists which generate the whole ALGEBRA."
  (labels ((check-first-subset-generates-algebra (subset)
             (cond
               ((null subset) nil)
               ((elements-generate-algebra-p (first subset) algebra)
                (first subset))
               (t (check-first-subset-generates-algebra (rest subset))))))
    (check-first-subset-generates-algebra (n-elemental-subsets (base-set-of algebra)
                                                               number-of-elements))))

(defun elements-generate-algebra-p (elements algebra)
  "Return non-NIL if ELEMENTS generate ALGEBRA."
  (let ((reachable-elements (all-reachable-elements elements algebra)))
    (cond
      ((set-equal reachable-elements (base-set-of algebra)) t)
      (t nil))))

(defun all-reachable-elements (elements algebra)
  "Returns all reachable elements from ELEMENTS in ALGEBRA."
  (let ((new-element (next-reachable-element algebra elements)))
    (cond
      ((not new-element) elements)
      (t (all-reachable-elements (cons new-element elements) algebra)))))

(defun next-reachable-element (algebra reachable-elements)
  "Returns new element in ALGEBRAS which is reachable by elements
from REACHABLE-ELEMENTS"
  (let ((value-tables (interpretations-on algebra)))
    (loop for table in value-tables
          do (iterate-over-function-graph (implementing-function-of table) element
               (when (and (subsetp (all-operands element) reachable-elements
				   :test (equal-pred-of-algebra algebra))
                          (not (member (value-of-element element) reachable-elements
				       :test (equal-pred-of-algebra algebra))))
                 (return-from next-reachable-element (values (value-of-element element)
                                                             (all-operands element)
                                                             (function-symbol-of table))))))))

;;; here is still a lot todo

(defun subalgebra-generated-by-elements (algebra elements)
  "Returns subalgebra in ALGEBRA generated by ELEMENTS being a set of elements in ALGEBRA."
  (cond
    ((not (subsetp elements (base-set-of algebra) :test (equal-pred-of-algebra algebra)))
     (error 'subalgebra-error
	    :text "Cannot generate algebra from elements not being in the algebra."))
    (t (let ((new-base-set (all-reachable-elements elements algebra)))
	 (cond
	   ((emptyp new-base-set)
	    (error 'subalgebra-error
		   :text "Cannot generate subalgebra from empty set."))
	   (t (make-algebra new-base-set
			    (signature-of algebra)
			    (restrict-interpretations-to-set (interpretations-on algebra)
							     new-base-set
							     (signature-of algebra)))))))))

(defun restrict-interpretations-to-set (interpretations set signature)
  (mapcar #'(lambda (interpre)
	      (restrict-table-to-set interpre set signature))
	  interpretations))

(defun restrict-table-to-set (table set signature)
  (let ((func-symbol (function-symbol-of table)))
    (list func-symbol
          (restrict-function-on-target
	   (restrict-function-on-source
	    (implementing-function-of table)
	    (tuples set (arity-of-function-symbol signature func-symbol)))
           set))))

;;;

;; (defun extend-graph-to-homomorphism-into-termalgebra (algebra graph)
;;   "Returns function being a homomorphism from ALGEBRA into the term-algebra
;; generated by the source of GRAPH being a subset of (BASE-SET-OF ALGEBRA)"
;;   (let ((source (mapcar #'first graph)))
;;     (cond
;;       ((not (subsetp (base-set-of algebra) source :test (equal-pred-of-algebra algebra)))
;;        (error 'subalgebra-error :text (format nil "Base set of ~A is not superset of source of ~A"
;;                                               algebra graph)))
;;       (t (let ((func (extend-from-elements-into-termalgebra algebra source graph)))
;;            (cond
;;              ((homomorphism-into-termalgebra-p func algebra
;;                                                (make-term-algebra source (signature-of algebra)))
;;               func)
;;              (t nil)))))))

;; (defun homomorphism-into-termalgebra-p (function algebra term-algebra)
;;   (and (set-equal (source function) (base-set-of function) :test (equal-pred-of-algebra algebra))
;;        (forall (element (base-set-of algebra))
;;          (let ((value (apply-function-to-element function element)))
;;            (termp term-algebra value)))

(defun extend-from-elements-into-termalgebra (algebra source graph)
  (multiple-value-bind (next-element operands function-symbol)
      (next-reachable-element algebra source)
    (cond
      ((null next-element)
       (make-function (mapcar #'first graph)
                      (mapcar #'second graph)
                      graph
		      :equal-pred (equal-pred-of-algebra algebra)))
      (t (let ((converted-operands (mapcar
				    #'(lambda (x)
					(second (assoc x graph :test (equal-pred-of-algebra algebra))))
				    operands)))
           (extend-from-elements-into-termalgebra
	    algebra
	    (cons next-element source)
	    (cons (list next-element
			(cons function-symbol converted-operands))
		  graph)))))))

(defun homomorphism-from-assignment (algebra elements graph)
  "Returns homomorphism extending GRAPH on ELEMENTS."
  (cond
    ((not (elements-generate-algebra-p elements algebra))
     (error 'subalgebra-error :text
	    (format nil "~A do not generate ~A" elements algebra)))
    ((not (subsetp elements (mapcar #'first graph) :test (equal-pred-of-algebra algebra)))
     (error 'subalgebra-error :text
	    (format nil "~A is not an assignment of ~A" graph elements)))
    (t (extend-from-elements-into-termalgebra algebra elements graph))))
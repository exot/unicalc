(in-package :uacalc-interface)

;;; free algebra

(defun uab-calculate-free-algebra (algebra-project size-of-algebra
                                   number-of-generators
                                   output-project)
  (declare (type uacalc-project algebra-project output-project)
	   (type integer size-of-algebra number-of-generators))
  "Writes commands to calculate the free algebra of ALGEBRA-PROJECT into (COMMAND-FILE ALGEBRA-PROJECT)"
  (let ((free-algebra-size (expt size-of-algebra number-of-generators)))
     (with-uab-command-to-file (stream (command-file algebra-project))
       (write-free-algebra-generators-to-file
          (vector-list-file-name output-project)
          size-of-algebra
          number-of-generators)
       (uab-commands-to-generate-subalgebra
          stream (file-name algebra-project)
          (vector-list-file-name
           output-project)
          (universe-file output-project))
      (write-uab-next-command stream)
      (uab-commands-to-create-direct-subproduct-algebra
          stream
          (universe-file output-project)
          free-algebra-size
          (file-name algebra-project)
          (file-name output-project)))
    (run-uab (pure-file-name algebra-project))))

(defun write-free-algebra-generators-to-file (filename size-of-algebra
                                              number-of-generators)
  (declare (type string filename)
	   (type integer size-of-algebra number-of-generators))
  "Writes the generating vectors of the free algebra into FILE-NAME"
  (let ((total-size (expt size-of-algebra number-of-generators)))
    (with-open-file (stream filename :direction :output
                                     :if-exists :supersede
                                     :if-does-not-exist :create)
      (write-vector-to-file stream (vector number-of-generators total-size))
      (format stream "~%")
      (loop for chunks = (/ total-size size-of-algebra)
            then (/ chunks size-of-algebra)
            for i below number-of-generators
            do (write-vector-to-file stream
                                     (distributed-vector total-size
                                                         chunks
                                                         size-of-algebra))))))

(defun distributed-vector (size chunks upper-limit) ;; to be improved
  (declare (type integer size chunks upper-limit))
  "Computes the generating vectors."
  (let ((vector (make-array size :initial-element 0)))
    (loop for i from 0 to (1- size)
          for element = -1 then element
          when (zerop (mod i chunks))
          do (setf element (mod (1+ element) upper-limit))
          do (setf (elt vector i) element)
          finally (return vector))))

(defun calculate-free-algebra (algebra number-of-generators)
  (declare (type algebra algebra)
	   (type integer number-of-generators))
  "Computes the free algebra of ALGEBRA in the varieaty generated by ALGEBRA
in NUMBER-OF-GENERATORS generators."
  (with-algebras ((origin-project algebra)) ((algebra-file-name result-project))
    (uab-calculate-free-algebra origin-project (card (base-set-of algebra))
                                number-of-generators result-project)))

(defun symbolize-free-algebra (algebra)
  (declare (type algebra algebra))
  "Returns ALGEBRA as factorized term algebra"
  (let* ((generating-elements (calculate-generating-elements algebra))
	 (symbols (symbol-list (card generating-elements)))
	 (homomorphism (homomorphism-from-assignment
			 algebra
			 generating-elements
			 (mapcar #'pair generating-elements
				 symbols))))
    (apply-quasihomomorphism-to-algebra homomorphism algebra)))

(defun extract-all-equations (symbolized-algebra)
  (let ((found-equations ()))
    (loop for table in (interpretations-on symbolized-algebra)
	  do
	  (let ((function-symbol (function-symbol-of table)))
	    (iterate-over-function-graph (implementing-function-of table)
		element
	      (push (list
		     (cons function-symbol (all-operands element))
		     (value-of-element element))
		    found-equations)))
	  finally (return found-equations))))

(defun pprint-all-equations (symbolized-algebra &optional (level 2))
  (let* ((variables (remove-if-not #'symbolp (base-set-of symbolized-algebra)))
	 (signature (signature-of symbolized-algebra))
	 (term-algebra (make-term-algebra variables signature)))
    (mapc #'(lambda (list)
	      (pprint-term-list term-algebra list))
	  (remove-all-weakly-dependent-equations
	   term-algebra
	   (extract-all-equations symbolized-algebra)
	   level))))
